//! A stateless, layered, multithread video system with OpenGL backends.
//!
//! # Overview and Goals
//!
//! The management of video effects has become an important topic and key feature of
//! rendering engines. With the increasing number of effects it is not sufficient anymore
//! to only support them, but also to integrate them into the rendering engine in a clean
//! and extensible way.
//!
//! The goal of this work and simultaneously its main contribution is to design and
//! implement an advanced effects framework. Using this framework it should be easy for
//! further applications to combine several small effects like texture mapping, shading
//! and shadowing in an automated and transparent way and apply them to any 3D model.
//! Additionally, it should be possible to integrate new effects and use the provided
//! framework for rapid prototyping.
//!
//! ### Multi Platform
//!
//! Ideally, crayon should be able to run on macOS, windows and popular mobile-platforms.
//! There still are a huge number of performance and feature limited devices, so this
//! video module will always be limited by lower-end 3D APIs like OpenGL ES2.0.
//!
//! ### Stateless Pipeline
//!
//! Ordinary OpenGL application deals with stateful APIs, which is error-prone. This
//! means whenever you change any state in the API for subsequent draw calls, this state
//! change also affects draw calls submitted at a later point in time. Ideally, submitting
//! a draw call with whatever state we want should not affect any of the other draw calls,
//! even in multi-thread environments.
//!
//! Modern 3D-APIs like [gfx-rs](https://github.com/gfx-rs/gfx), [glium](https://github.com/glium/glium)
//! bundles render state and data into a few, precompiled resource objects which are
//! combined into final render pipeline. We should follow the same philosophy.
//!
//! ### Multi-thread
//!
//! In most cases, dividing OpenGL rendering across multiple threads will not result in
//! any performance improvement due the pipeline nature of OpenGL. What we are about
//! to do is actually exploiting parallelism in resource preparation, and provides a set of
//! multi-thread friendly APIs.
//!
//! The most common solution is by using a double-buffer of commands. This consists of
//! running the renderer backend in a speparate thread, where all draw calls and communication
//! with the OpenGL API are performed. The frontend thread that runs the game logic
//! communicates with the backend renderer via a command double-buffer.
//!
//! ### Layered Rendering
//!
//! Its important to sort video commands (generated by different threads) before submiting
//! them to OpenGL, for the sack of both correctness and performance. For example, to draw
//! transparent objects via blending, we need draw opaque object first, usually from front-to-back,
//! and draw translucents from back-to-front.
//!
//! The idea here is to assign a integer key to a command which is used for sorting. Depending
//! on where those bits are stored in the integer, you can apply different sorting criteria
//! for the same array of commands, as long as you know how the keys were built.
//!
//! # Resource Objects
//!
//! Render state and data, which are combined into final render pipeline, are bundled into a
//! few, precompiled resource objects in video module.
//!
//! All resources types can be created instantly from data in memory, and meshes, textures
//! can also be loaded asynchronously from the filesystem.
//!
//! And the actual resource objects are usually private and opaque, you will get a `Handle`
//! immediately for every resource objects you created instead of some kind of reference.
//! Its the unique identifier for the resource, its type-safe and copyable.
//!
//! When you are done with the created resource objects, its your responsiblity to delete the
//! resource object with `Handle` to avoid leaks.
//!
//! For these things loaded from filesystem, it could be safely shared by the `Location`. We
//! keeps a use-counting internally. It will not be freed really, before all the users deletes
//! its `Handle`.
//!
//! ### Surface Object
//!
//! Surface object plays as the `Layer` role we mentioned above, all the commands we submitted
//! in application code is attached to a specific `Surface`. Commands inside `Surface` are
//! sorted before submitting to underlying OpenGL.
//!
//! Surface object also holds references to render target, and wraps rendering operations to
//! it. Likes clearing, offscreen-rendering, MSAA resolve etc..
//!
//! ```rust
//! use crayon::video::prelude::*;
//! use crayon::math::Color;
//! let video = VideoSystem::headless(None).shared();
//!
//! // Creates a `SurfaceParams` object.
//! let mut params = SurfaceParams::default();
//! /// Sets the attachments of internal frame-buffer. It consists of multiple color attachments
//! /// and a optional `Depth/DepthStencil` buffer attachment.
//! ///
//! /// If none attachment is assigned, the default framebuffer generated by the system will be
//! /// used.
//! params.set_attachments(&[], None);
//! // Sets the clear flags for this surface and its underlying framebuffer.
//! params.set_clear(Color::white(), 1.0, None);
//!
//! // Creates an surface with `SurfaceParams`.
//! let surface = video.create_surface(params).unwrap();
//! // Deletes the surface object.
//! video.delete_surface(surface);
//! ```
//!
//! ### Shader Object
//!
//! Shader object is introduced to encapsulate all stateful things we need to configurate
//! video pipeline. This would also enable us to easily change the order of draw calls
//! and get rid of redundant state changes.
//!
//! ```rust
//! use crayon::video::prelude::*;
//! let video = VideoSystem::headless(None).shared();
//!
//! // Declares the uniform variable layouts.
//! let mut uniforms = UniformVariableLayout::build()
//!     .with("u_ModelViewMatrix", UniformVariableType::Matrix4f)
//!     .with("u_MVPMatrix", UniformVariableType::Matrix4f)
//!     .finish();
//!
//! // Declares the attributes.
//! let attributes = AttributeLayout::build()
//!      .with(Attribute::Position, 3)
//!      .with(Attribute::Normal, 3)
//!      .finish();
//!
//! let mut params = ShaderParams::default();
//! params.attributes = attributes;
//! params.uniforms = uniforms;
//! params.state = RenderState::default();
//!
//! let vs = "..".into();
//! let fs = "..".into();
//!
//! // Create a shader with initial shaders and render state. It encapusulates all the
//! // informations we need to configurate graphics pipeline before real drawing.
//! let shader = video.create_shader(params, vs, fs).unwrap();
//!
//! // Deletes shader object.
//! video.delete_shader(shader);
//! ```
//!
//! ### Texture Object
//!
//! A texture object is a container of one or more images. It can be the source of a texture
//! access from a Shader.
//!
//! ```rust
//! use crayon::video::prelude::*;
//! let video = VideoSystem::headless(None).shared();
//!
//! let mut params = TextureParams::default();
//!
//! // Create a texture object with optional data. You can fill it later with `update_texture`.
//! let texture = video.create_texture(params, None).unwrap();
//!
//! // Deletes the texture object.
//! video.delete_texture(texture);
//! ```
//!
//! #### Compressed Texture Format
//!
//! _TODO_: Cube texture.
//! _TODO_: 3D texture.
//!
//! ### Mesh Object
//!
//! ```rust
//! use crayon::video::prelude::*;
//! let video = VideoSystem::headless(None).shared();
//!
//! let mut params = MeshParams::default();
//!
//! // Create a mesh object with optional data. You can fill it later with `update_mesh`.
//! let mesh = video.create_mesh(params, None).unwrap();
//!
//! // Deletes the mesh object.
//! video.delete_mesh(mesh);
//! ```
//!
//! # Commands
//!
//! Finally, when we finished the preparation of video resources, to make draw call:
//!
//! ```rust
//! use crayon::video::prelude::*;
//! use crayon::math;
//! let video = VideoSystem::headless(None).shared();
//!
//! let mut params = SurfaceParams::default();
//! // ..
//! let surface = video.create_surface(params).unwrap();
//!
//! let mut params = MeshParams::default();
//! // ...
//! let mesh = video.create_mesh(params, None).unwrap();
//!
//! let mut params = ShaderParams::default();
//! // ...
//! let vs = "..".into();
//! let fs = "..".into();
//! let shader = video.create_shader(params, vs, fs).unwrap();
//!
//! // Creates a draw call with specified shader and mesh object.
//! let mut dc = DrawCall::new(shader, mesh);
//! // You can set the uniform variables for this dc.
//! dc.set_uniform_variable("someUniform", math::Vector3::new(0.0, 0.0, 0.0));
//! // Commits the draw call into surface.
//! video.draw(surface, dc);
//! ```
//!
//! _TODO_: Batch
//! _TODO_: OrderDrawBatch

/// Maximum number of attributes in vertex layout.
pub const MAX_VERTEX_ATTRIBUTES: usize = 12;
/// Maximum number of attachments in framebuffer.
pub const MAX_FRAMEBUFFER_ATTACHMENTS: usize = 8;
/// Maximum number of uniform variables in shader.
pub const MAX_UNIFORM_VARIABLES: usize = 32;
/// Maximum number of textures in shader.
pub const MAX_UNIFORM_TEXTURE_SLOTS: usize = 8;

#[macro_use]
pub mod assets;
pub mod batch;
pub mod errors;

mod backends;

pub mod prelude {
    pub use super::assets::prelude::*;
    pub use super::batch::{Batch, DrawCall, OrderDrawBatch};
    pub use super::{VideoFrameInfo, VideoSystem, VideoSystemShared};
}

use std::sync::{Arc, RwLock};
use std::time::Duration;
use uuid::Uuid;

use application::window::Window;
use math;
use res::prelude::{Location, ResourceSystemShared};
use res::registry::Registry;
use utils::ObjectPool;

use self::assets::prelude::*;
use self::backends::frame::*;
use self::backends::gl::visitor::GLVisitor;
use self::backends::Visitor;
use self::batch::DrawCall;
use self::errors::*;

/// The information of video module during last frame.
#[derive(Debug, Copy, Clone, Default)]
pub struct VideoFrameInfo {
    pub duration: Duration,
    pub drawcall: u32,
    pub triangles: u32,
    pub alive_surfaces: u32,
    pub alive_shaders: u32,
    pub alive_meshes: u32,
    pub alive_textures: u32,
}

/// The centralized management of video sub-system.
pub struct VideoSystem {
    visitor: Box<Visitor>,
    frames: Arc<DoubleFrame>,
    shared: Arc<VideoSystemShared>,
    last_dimensions: math::Vector2<u32>,
}

impl VideoSystem {
    /// Create a new `VideoSystem` with one `Window` context.
    pub fn new(window: &Window, res: Arc<ResourceSystemShared>) -> ::errors::Result<Self> {
        let frames = Arc::new(DoubleFrame::with_capacity(64 * 1024));
        let shared = VideoSystemShared::new(frames.clone(), res);
        let visitor = unsafe { Box::new(GLVisitor::new()?) };

        Ok(VideoSystem {
            last_dimensions: window.dimensions(),
            visitor: visitor,

            frames: frames,
            shared: Arc::new(shared),
        })
    }

    /// Creates a new headless `VideoSystem`.
    pub fn headless<T>(res: T) -> Self
    where
        T: Into<Option<Arc<ResourceSystemShared>>>,
    {
        let res = res.into().unwrap_or_else(|| {
            let sched = ::sched::ScheduleSystem::new(1, None, None);
            ::res::ResourceSystem::new(sched.shared()).unwrap().shared()
        });

        let frames = Arc::new(DoubleFrame::with_capacity(0));
        let shared = VideoSystemShared::new(frames.clone(), res);
        let visitor = backends::headless::HeadlessVisitor::new();

        VideoSystem {
            last_dimensions: (0, 0).into(),
            visitor: Box::new(visitor),
            frames: frames,
            shared: Arc::new(shared),
        }
    }

    /// Returns the multi-thread friendly parts of `VideoSystem`.
    pub fn shared(&self) -> Arc<VideoSystemShared> {
        self.shared.clone()
    }

    /// Swap internal commands frame.
    #[inline]
    pub fn swap_frames(&self) {
        self.frames.swap_frames();
    }

    /// Advance to next frame.
    ///
    /// Notes that this method MUST be called at main thread, and will NOT return
    /// until all commands is finished by GPU.
    pub fn advance(&mut self, window: &Window) -> ::errors::Result<VideoFrameInfo> {
        use std::time;

        let ts = time::Instant::now();
        let dimensions = window.dimensions();

        // Resize the window, which would recreate the underlying framebuffer.
        if dimensions != self.last_dimensions {
            self.last_dimensions = dimensions;
            window.resize(dimensions);
        }

        let (dc, tris) = self
            .frames
            .back()
            .dispatch(self.visitor.as_mut(), dimensions)?;
        let mut info = VideoFrameInfo::default();

        {
            let s = &self.shared;
            info.alive_surfaces = s.surfaces.write().unwrap().len() as u32;
            info.alive_shaders = s.shaders.write().unwrap().len() as u32;
            info.alive_meshes = s.meshes.len() as u32;
            info.alive_textures = s.textures.len() as u32;
            info.drawcall = dc;
            info.triangles = tris;
        }

        info.duration = time::Instant::now() - ts;
        Ok(info)
    }
}

pub type TextureRegistry = Registry<TextureHandle, self::assets::texture_loader::TextureLoader>;
pub type MeshRegistry = Registry<MeshHandle, self::assets::mesh_loader::MeshLoader>;

/// The multi-thread friendly parts of `VideoSystem`.
pub struct VideoSystemShared {
    pub(crate) frames: Arc<DoubleFrame>,

    surfaces: RwLock<ObjectPool<SurfaceHandle, SurfaceParams>>,
    shaders: RwLock<ObjectPool<ShaderHandle, ShaderParams>>,
    meshes: MeshRegistry,
    textures: TextureRegistry,
    render_textures: RwLock<ObjectPool<RenderTextureHandle, RenderTextureParams>>,
}

impl VideoSystemShared {
    /// Create a new `VideoSystem` with one `Window` context.
    fn new(frames: Arc<DoubleFrame>, res: Arc<ResourceSystemShared>) -> Self {
        use self::assets::mesh_loader::MeshLoader;
        use self::assets::texture_loader::TextureLoader;

        let textures = TextureRegistry::new(res.clone(), TextureLoader::new(frames.clone()));
        let meshes = MeshRegistry::new(res.clone(), MeshLoader::new(frames.clone()));

        VideoSystemShared {
            frames: frames,

            surfaces: RwLock::new(ObjectPool::new()),
            shaders: RwLock::new(ObjectPool::new()),
            meshes: meshes,
            textures: textures,
            render_textures: RwLock::new(ObjectPool::new()),
        }
    }

    /// Draws ur mesh.
    ///
    /// Notes that you should use [Batch](crate::video::batch::Batch) if possible.
    #[inline]
    pub fn draw(&self, handle: SurfaceHandle, dc: DrawCall) {
        let mut frame = self.frames.front();
        let len = dc.uniforms_len;
        let ptr = frame.bufs.extend_from_slice(&dc.uniforms[0..len]);
        let cmd = Command::Draw(dc.shader, dc.mesh, dc.mesh_index, ptr);

        frame.cmds.push(Command::Bind(handle));
        frame.cmds.push(cmd);
    }

    /// Updates the scissor test of surface.
    ///
    /// The test is initially disabled. While the test is enabled, only pixels that lie within
    /// the scissor box can be modified by drawing commands.
    ///
    /// Notes that you should use [Batch](crate::video::batch::Batch) if possible.
    #[inline]
    pub fn update_scissor(&self, handle: SurfaceHandle, scissor: SurfaceScissor) {
        let mut frame = self.frames.front();
        frame.cmds.push(Command::Bind(handle));
        frame.cmds.push(Command::UpdateScissor(scissor));
    }

    /// Updates the scissor test of surface.
    ///
    /// The test is initially disabled. While the test is enabled, only pixels that lie within
    /// the scissor box can be modified by drawing commands.
    ///
    /// Notes that you should use [Batch](crate::video::batch::Batch) if possible.
    #[inline]
    pub fn update_viewport(&self, handle: SurfaceHandle, viewport: SurfaceViewport) {
        let mut frame = self.frames.front();
        frame.cmds.push(Command::Bind(handle));
        frame.cmds.push(Command::UpdateViewport(viewport));
    }
}

impl VideoSystemShared {
    /// Creates an surface with `SurfaceParams`.
    pub fn create_surface(&self, params: SurfaceParams) -> Result<SurfaceHandle> {
        let handle = self.surfaces.write().unwrap().create(params).into();

        {
            let cmd = Command::CreateSurface(handle, params);
            self.frames.front().cmds.push(cmd);
        }

        Ok(handle)
    }

    /// Gets the `SurfaceParams` if available.
    pub fn surface(&self, handle: SurfaceHandle) -> Option<SurfaceParams> {
        self.surfaces.read().unwrap().get(handle).cloned()
    }

    /// Deletes surface object.
    pub fn delete_surface(&self, handle: SurfaceHandle) {
        if self.surfaces.write().unwrap().free(handle).is_some() {
            let cmd = Command::DeleteSurface(handle);
            self.frames.front().cmds.push(cmd);
        }
    }
}

impl VideoSystemShared {
    /// Create a shader with initial shaders and render state. It encapusulates all the
    /// informations we need to configurate graphics pipeline before real drawing.
    pub fn create_shader(
        &self,
        params: ShaderParams,
        vs: String,
        fs: String,
    ) -> Result<ShaderHandle> {
        params.validate(&vs, &fs)?;

        let handle = self.shaders.write().unwrap().create(params.clone()).into();

        {
            let cmd = Command::CreateShader(handle, params, vs, fs);
            self.frames.front().cmds.push(cmd);
        }

        Ok(handle)
    }

    /// Gets the `ShaderParams` if available.
    pub fn shader(&self, handle: ShaderHandle) -> Option<ShaderParams> {
        self.shaders.read().unwrap().get(handle).cloned()
    }

    /// Delete shader state object.
    pub fn delete_shader(&self, handle: ShaderHandle) {
        if self.shaders.write().unwrap().free(handle).is_some() {
            let cmd = Command::DeleteShader(handle);
            self.frames.front().cmds.push(cmd);
        }
    }
}

impl VideoSystemShared {
    /// Create a new mesh object.
    #[inline]
    pub fn create_mesh<T>(&self, params: MeshParams, data: T) -> ::errors::Result<MeshHandle>
    where
        T: Into<Option<MeshData>>,
    {
        let handle = self.meshes.create((params, data.into()))?;
        Ok(handle)
    }

    /// Creates a mesh object from file asynchronously.
    #[inline]
    pub fn create_mesh_from<'a, T>(&'a self, location: T) -> ::errors::Result<MeshHandle>
    where
        T: Into<Location<'a>>,
    {
        let handle = self.meshes.create_from(location)?;
        Ok(handle)
    }

    /// Creates a mesh object from file asynchronously.
    #[inline]
    pub fn create_mesh_from_uuid(&self, uuid: Uuid) -> ::errors::Result<MeshHandle> {
        let handle = self.meshes.create_from_uuid(uuid)?;
        Ok(handle)
    }

    /// Gets the `MeshParams` if available.
    #[inline]
    pub fn mesh_aabb(&self, handle: MeshHandle) -> Option<math::Aabb3<f32>> {
        self.meshes.get(handle, |v| v.aabb)
    }

    /// Update a subset of dynamic vertex buffer. Use `offset` specifies the offset
    /// into the buffer object's data store where data replacement will begin, measured
    /// in bytes.
    pub fn update_vertex_buffer(
        &self,
        handle: MeshHandle,
        offset: usize,
        data: &[u8],
    ) -> ::errors::Result<()> {
        self.meshes
            .get(handle, |_| {
                let mut frame = self.frames.front();
                let ptr = frame.bufs.extend_from_slice(data);
                let cmd = Command::UpdateVertexBuffer(handle, offset, ptr);
                frame.cmds.push(cmd);
            }).ok_or_else(|| format_err!("{:?}", handle))
    }

    /// Update a subset of dynamic index buffer. Use `offset` specifies the offset
    /// into the buffer object's data store where data replacement will begin, measured
    /// in bytes.
    pub fn update_index_buffer(
        &self,
        handle: MeshHandle,
        offset: usize,
        data: &[u8],
    ) -> ::errors::Result<()> {
        self.meshes
            .get(handle, |_| {
                let mut frame = self.frames.front();
                let ptr = frame.bufs.extend_from_slice(data);
                let cmd = Command::UpdateIndexBuffer(handle, offset, ptr);
                frame.cmds.push(cmd);
            }).ok_or_else(|| format_err!("{:?}", handle))
    }

    /// Delete mesh object.
    #[inline]
    pub fn delete_mesh(&self, handle: MeshHandle) {
        self.meshes.delete(handle);
    }
}

impl VideoSystemShared {
    /// Create texture object. A texture is an image loaded in video memory,
    /// which can be sampled in shaders.
    pub fn create_texture<T>(
        &self,
        params: TextureParams,
        data: T,
    ) -> ::errors::Result<TextureHandle>
    where
        T: Into<Option<TextureData>>,
    {
        let handle = self.textures.create((params, data.into()))?;
        Ok(handle)
    }

    /// Creates a texture object from file asynchronously.
    pub fn create_texture_from<'a, T>(&'a self, location: T) -> ::errors::Result<TextureHandle>
    where
        T: Into<Location<'a>>,
    {
        let handle = self.textures.create_from(location)?;
        Ok(handle)
    }

    /// Creates a texture object from file asynchronously.
    pub fn create_texture_from_uuid(&self, uuid: Uuid) -> ::errors::Result<TextureHandle> {
        let handle = self.textures.create_from_uuid(uuid)?;
        Ok(handle)
    }

    /// Update a contiguous subregion of an existing two-dimensional texture object.
    pub fn update_texture(
        &self,
        handle: TextureHandle,
        area: math::Aabb2<u32>,
        data: &[u8],
    ) -> ::errors::Result<()> {
        self.textures
            .get(handle, |_| {
                let mut frame = self.frames.front();
                let ptr = frame.bufs.extend_from_slice(data);
                let cmd = Command::UpdateTexture(handle, area, ptr);
                frame.cmds.push(cmd);
            }).ok_or_else(|| format_err!("{:?}", handle))
    }

    /// Delete the texture object.
    pub fn delete_texture(&self, handle: TextureHandle) {
        self.textures.delete(handle);
    }
}

impl VideoSystemShared {
    /// Create render texture object, which could be attached with a framebuffer.
    pub fn create_render_texture(
        &self,
        params: RenderTextureParams,
    ) -> Result<RenderTextureHandle> {
        let handle = self.render_textures.write().unwrap().create(params).into();

        {
            let cmd = Command::CreateRenderTexture(handle, params);
            self.frames.front().cmds.push(cmd);
        }

        Ok(handle)
    }

    /// Gets the `RenderTextureParams` if available.
    pub fn render_texture(&self, handle: RenderTextureHandle) -> Option<RenderTextureParams> {
        self.render_textures.read().unwrap().get(handle).cloned()
    }

    /// Delete the render texture object.
    pub fn delete_render_texture(&self, handle: RenderTextureHandle) {
        if self.render_textures.write().unwrap().free(handle).is_some() {
            let cmd = Command::DeleteRenderTexture(handle);
            self.frames.front().cmds.push(cmd);
        }
    }
}
